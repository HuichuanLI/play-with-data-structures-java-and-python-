
# 哈希表

## hash 函数的设计
### 小范围正整数直接使用 
### 小范围负整数进行偏移 
### 100～100 -> 0～200 

### 大整数 身份证号 110108198512166666 
### 通常做法，取模 比如，取后四位。等同于mod 10000
### 分布不均匀 因为日子不可能超过 32
### 具体问题具体分析
### 没有利用所有的信息 取mo一个素数 最好取一个素数


#### 166=1*10^2+6*10^1+6*10^0 

#### code=（c*26^3+0*26^2+d*26^1+e*26^0）
#### code=（c*B^3+0*B^2+d*B^1+e*B^O) 
#### hash(code)=(c*B^3+o*B^2+d*B^d+e*B^O)％M
#### hash(code)= ((((c%M)*B+o)%M*B+d)%M*B+e)%M

#### 复合类型 
#### 转成整形
#### Data: year,month,day
#### hash(date) = (((date.year%M)*B+date.month)%M*B+date.day)%M


### 原则

#### 1.一致性：如果a==b,则hash(a)==hash(b)，反过来不行
#### 2·高效性：计算高效简便 
#### 3．均匀性：哈希值均匀分布

#### hash 冲突 -- 链地址法
#### hashCode(k1)%M 
#### (hashcode(k1) & 0x7fffffff)%M
#### 每个位置都是对应就是一个链表或者TreeMap 红黑树

### 总共有M个地址 如果放入哈希表的元素为N 如果每个地址是链表：O(N/M） 
### 如果每个地址是平衡树：0(log（N/M）)
### 如果平均每个地址的元素超过一定程度，那么就扩容
### 如果平均每个地址的元素少于一定程度，那么就缩容


### hash 时间复杂度
### 平均复杂度 O(1) 每个操作在O(lowerTol) ~ O(upperTol)
### 2*M 不是素数 可以不是简单的扩容

### 哈希表：均摊复杂度O(1)
### 但是相对于AVL 没有顺序性，集合和映射
### 有序 平衡树 TreeMAP
### 无序 Hashmap hashmap 不用链表，但是对于java8 之后就是红黑树，如果一开始用链表，如果hash冲突多了就用红黑树TreeMap


### 更多 解决hash冲突 
#### 链地址法
#### 开放地址法 对于开放地址就是一块地址，往后找下一个开放地址，线性探测法，平方探测法，二次hash法，负载率大于多少的情况下扩容
#### 再hash法 rehashing  再拿一个hash 函数再计算index
#### coalesed Hashing
